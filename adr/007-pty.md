# ADR-007: PTY Allocation for Subprocess Execution

**Date:** 2026-02-21
**Status:** Accepted (supersedes [ADR-003](003-no-pty-v1.md))

## Context

ADR-003 deferred PTY allocation because of three concerns: pager activation,
signal forwarding complexity, and dependency surface. Since then:

1. **Pager activation** is a feature, not a bug. When the user runs `git log`
   inside cobra-shell and a pager launches, that is the expected behaviour —
   exactly what would happen in a real shell. ADR-003 framed pager launches as
   a "broken display" problem, but with proper PTY + raw-mode forwarding the
   pager works correctly.

2. **Signal forwarding** via raw-mode terminal eliminates complexity rather
   than adding it. With `term.MakeRaw`, Ctrl-C becomes byte 0x03 forwarded to
   the PTY master; the slave's line discipline delivers SIGINT to the subprocess
   process group. The parent needs no `signal.Notify` at all in the PTY path.
   (The plain-fallback path retains the existing `signal.Notify` approach.)

3. **Dependency surface** is acceptable. `github.com/creack/pty` and
   `golang.org/x/term` are small, well-maintained packages with no transitive
   dependencies beyond `golang.org/x/sys` (already required).

## Decision

Allocate a PTY for every subprocess spawned by `Shell.execute()`. Auto-detect
whether PTY should be used via `term.IsTerminal(os.Stdin.Fd())`: when stdin is
a real terminal, use `spawnWithPTY`; otherwise fall back to `runPlain`. This
keeps tests (non-TTY stdin) and pipelines working without any config option.

`tryComplete()` is explicitly excluded from PTY — it captures stdout in a
`bytes.Buffer` and must remain a plain subprocess.

### Implementation

```
spawnCommand(binary, tokens, env)
  ├── term.IsTerminal(stdin) == true
  │     ├── pty.Start(cmd) == nil  →  runWithPTY(cmd, ptmx)
  │     └── pty.Start(cmd) error   →  runPlain(cmd)   (fallback)
  └── term.IsTerminal(stdin) == false  →  runPlain(cmd)
```

`runWithPTY`:
1. `signal.Notify(SIGWINCH)` + goroutine calling `pty.InheritSize` on each signal.
2. `term.MakeRaw(stdin)` — disables ISIG so Ctrl-C is forwarded as 0x03.
3. `go io.Copy(ptmx, os.Stdin)` — forward keystrokes to subprocess.
4. `io.Copy(os.Stdout, ptmx)` — stream subprocess output (blocks until slave closes).
5. `term.Restore(stdin)` on exit.
6. `cmd.Wait()` — collect exit code.

`runPlain` (non-TTY / PTY failure):
- Inherits stdin/stdout/stderr.
- `signal.Notify(os.Interrupt)` to suppress SIGINT in parent (unchanged from v1).

## Consequences

- Color output works automatically for any binary that checks `isatty`.
- Interactive subcommands (`vim`, `less`, `ssh`) work correctly.
- `Config.Env: []string{"FORCE_COLOR=1"}` is no longer needed for most binaries
  but remains supported.
- The `FORCE_COLOR` workaround note in the README is updated to reflect this.
- Subprocess mode is now Unix-only in a stronger sense (PTY is a POSIX concept).
  This is consistent with the existing "Unix only" limitation.
